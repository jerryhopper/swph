#!/bin/bash

set -e



# Check an IP address to see if it is a valid one
valid_ip() {
    # Local, named variables
    local ip=${1}
    local stat=1

    # If the IP matches the format xxx.xxx.xxx.xxx,
    if [[ "${ip}" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Save the old Internal Field Separator in a variable
        OIFS=$IFS
        # and set the new one to a dot (period)
        IFS='.'
        # Put the IP into an array
        ip=(${ip})
        # Restore the IFS to what it was
        IFS=${OIFS}
        ## Evaluate each octet by checking if it's less than or equal to 255 (the max for each octet)
        [[ "${ip[0]}" -le 255 && "${ip[1]}" -le 255 \
        && "${ip[2]}" -le 255 && "${ip[3]}" -le 255 ]]
        # Save the exit code
        stat=$?
    fi
    # Return the exit code
    return ${stat}
}


find_IPv4_information() {
    # Detects IPv4 address used for communication to WAN addresses.
    # Accepts no arguments, returns no values.

    # Named, local variables
    local route
    local IPv4bare

    # Find IP used to route to outside world by checking the the route to Google's public DNS server
    route=$(ip route get 8.8.8.8)

    # Get just the interface IPv4 address
    # shellcheck disable=SC2059,SC2086
    # disabled as we intentionally want to split on whitespace and have printf populate
    # the variable with just the first field.
    printf -v IPv4bare "$(printf ${route#*src })"
    # Get the default gateway IPv4 address (the way to reach the Internet)
    # shellcheck disable=SC2059,SC2086
    printf -v IPv4gw "$(printf ${route#*via })"

    if ! valid_ip "${IPv4bare}" ; then
        IPv4bare="127.0.0.1"
    fi

    # Append the CIDR notation to the IP address, if valid_ip fails this should return 127.0.0.1/8
    IPV4_ADDRESS=$(ip -oneline -family inet address show | grep "${IPv4bare}/" |  awk '{print $4}' | awk 'END {print}')
}

piholeftlconf(){
  echo "PRIVACYLEVEL=0" >/etc/pihole/pihole-FTL.conf
  echo "BLOCKINGMODE=IP-NODATA-AAAA" >>/etc/pihole/pihole-FTL.conf

}

piholesetupvarsconf(){
    mkdir -p /etc/pihole
    echo "PIHOLE_INTERFACE=eth0" >/etc/pihole/setupVars.conf
    #echo "IPV4_ADDRESS=10.0.1.207/24" >>/etc/pihole/setupVars.conf
    echo "IPV4_ADDRESS=$IPV4_ADDRESS" >>/etc/pihole/setupVars.conf
    echo "IPV6_ADDRESS=" >>/etc/pihole/setupVars.conf
    echo "PIHOLE_DNS_1=8.8.8.8" >>/etc/pihole/setupVars.conf
    echo "PIHOLE_DNS_2=8.8.4.4" >>/etc/pihole/setupVars.conf
    echo "QUERY_LOGGING=false" >>/etc/pihole/setupVars.conf
    echo "INSTALL_WEB_SERVER=true" >>/etc/pihole/setupVars.conf
    echo "INSTALL_WEB_INTERFACE=true" >>/etc/pihole/setupVars.conf
    echo "LIGHTTPD_ENABLED=true" >>/etc/pihole/setupVars.conf
    echo "BLOCKING_ENABLED=true" >>/etc/pihole/setupVars.conf
    echo "DNSMASQ_LISTENING=single" >>/etc/pihole/setupVars.conf
    echo "DNS_FQDN_REQUIRED=true" >>/etc/pihole/setupVars.conf
    echo "DNS_BOGUS_PRIV=true" >>/etc/pihole/setupVars.conf
    #echo "DNSSEC=true" >>/etc/pihole/setupVars.conf
    echo "TEMPERATUREUNIT=C" >>/etc/pihole/setupVars.conf
    #echo "CONDITIONAL_FORWARDING=true" >>/etc/pihole/setupVars.conf
    #echo "CONDITIONAL_FORWARDING_IP=10.0.1.1" >>/etc/pihole/setupVars.conf
    #echo "CONDITIONAL_FORWARDING_DOMAIN=localdomain" >>/etc/pihole/setupVars.conf
    #echo "CONDITIONAL_FORWARDING_REVERSE=1.0.10.in-addr.arpa" >>/etc/pihole/setupVars.conf
    echo "WEBPASSWORD=84ea6bece4df810e8a3d53ba0e6c5ff9cdc5c25ddd2d8b6ad5c5e009015c3e54" >>/etc/pihole/setupVars.conf

}


is_command() {
    # Checks for existence of string passed in as only function argument.
    # Exit value of 0 when exists, 1 if not exists. Value is the result
    # of the `command` shell built-in call.
    local check_command="$1"

    command -v "${check_command}" >/dev/null 2>&1
}

# A function for checking if a directory is a git repository
is_repo() {
    # Use a named, local variable instead of the vague $1, which is the first argument passed to this function
    # These local variables should always be lowercase
    local directory="${1}"
    # A local variable for the current directory
    local curdir
    # A variable to store the return code
    local rc
    # Assign the current directory variable by using pwd
    curdir="${PWD}"
    # If the first argument passed to this function is a directory,
    if [[ -d "${directory}" ]]; then
        # move into the directory
        cd "${directory}"
        # Use git to check if the directory is a repo
        # git -C is not used here to support git versions older than 1.8.4
        git status --short &> /dev/null || rc=$?
    # If the command was not successful,
    else
        # Set a non-zero return code if directory does not exist
        rc=1
    fi
    # Move back into the directory the user started in
    cd "${curdir}"
    # Return the code; if one is not set, return 0
    return "${rc:-0}"
}


# A function to clone a repo
make_repo() {
    # Set named variables for better readability
    local directory="${1}"
    local remoteRepo="${2}"
    # The message to display when this function is running
    str="Clone ${remoteRepo} into ${directory}"
    # Display the message and use the color table to preface the message with an "info" indicator
    printf "  %b %s..." "${INFO}" "${str}"
    # If the directory exists,
    if [[ -d "${directory}" ]]; then
        # delete everything in it so git can clone into it
        rm -rf "${directory}"
    fi
    # Clone the repo and return the return code from this command
    git clone -q --depth 20 "${remoteRepo}" "${directory}" &> /dev/null || return $?
    # Show a colored message showing it's status
    printf "%b  %b %s\\n" "${OVER}" "${TICK}" "${str}"
    # Always return 0? Not sure this is correct
    return 0
}

# We need to make sure the repos are up-to-date so we can effectively install Clean out the directory if it exists for git to clone into
update_repo() {
    # Use named, local variables
    # As you can see, these are the same variable names used in the last function,
    # but since they are local, their scope does not go beyond this function
    # This helps prevent the wrong value from being assigned if you were to set the variable as a GLOBAL one
    local directory="${1}"
    local curdir

    # A variable to store the message we want to display;
    # Again, it's useful to store these in variables in case we need to reuse or change the message;
    # we only need to make one change here
    local str="Update repo in ${1}"

    # Make sure we know what directory we are in so we can move back into it
    curdir="${PWD}"
    # Move into the directory that was passed as an argument
    cd "${directory}" &> /dev/null || return 1
    # Let the user know what's happening
    printf "  %b %s..." "${INFO}" "${str}"
    # Stash any local commits as they conflict with our working code
    git stash --all --quiet &> /dev/null || true # Okay for stash failure
    git clean --quiet --force -d || true # Okay for already clean directory
    # Pull the latest commits
    git pull --quiet &> /dev/null || return $?
    # Show a completion message
    printf "%b  %b %s\\n" "${OVER}" "${TICK}" "${str}"
    # Move back into the original directory
    cd "${curdir}" &> /dev/null || return 1
    return 0
}

# A function that combines the functions previously made
getGitFiles() {
    # Setup named variables for the git repos
    # We need the directory
    local directory="${1}"
    # as well as the repo URL
    local remoteRepo="${2}"
    # A local variable containing the message to be displayed
    local str="Check for existing repository in ${1}"
    # Show the message
    printf "  %b %s..." "${INFO}" "${str}"
    # Check if the directory is a repository
    if is_repo "${directory}"; then
        # Show that we're checking it
        printf "%b  %b %s\\n" "${OVER}" "${TICK}" "${str}"
        # Update the repo, returning an error message on failure
        update_repo "${directory}" || { printf "\\n  %b: Could not update local repository. Contact support.%b\\n" "${COL_LIGHT_RED}" "${COL_NC}"; exit 1; }
    # If it's not a .git repo,
    else
        # Show an error
        printf "%b  %b %s\\n" "${OVER}" "${CROSS}" "${str}"
        # Attempt to make the repository, showing an error on failure
        make_repo "${directory}" "${remoteRepo}" || { printf "\\n  %bError: Could not update local repository. Contact support.%b\\n" "${COL_LIGHT_RED}" "${COL_NC}"; exit 1; }
    fi
    # echo a blank line
    echo ""
    # and return success?
    return 0
}

# Reset a repo to get rid of any local changed
resetRepo() {
    # Use named variables for arguments
    local directory="${1}"
    # Move into the directory
    cd "${directory}" &> /dev/null || return 1
    # Store the message in a variable
    str="Resetting repository within ${1}..."
    # Show the message
    printf "  %b %s..." "${INFO}" "${str}"
    # Use git to remove the local changes
    git reset --hard &> /dev/null || return $?
    # And show the status
    printf "%b  %b %s\\n" "${OVER}" "${TICK}" "${str}"
    # Returning success anyway?
    return 0
}
includeSources(){
    source "/usr/share/blackbox/func/devicelog.sh"
    source "/usr/share/blackbox/func/telegram.sh"
    source "/usr/share/blackbox/func/valid_ip.sh"
    source "/usr/share/blackbox/func/find_ip4_information.sh"
}


SCRIPT_FILENAME="blackbox"
INSTALLSTATE=none



#echo "1=$1 2=$2 3=$3"

if [ "$1" == "" ]; then
  echo "blackbox"
  echo "Usage: blackbox [option] "
  echo "Options : install, configure, check "
  exit 0
fi

# load blackbox.conf
if [ -f "/etc/blackbox/blackbox.conf" ]; then
  source "/etc/blackbox/blackbox.conf"
  echo "bbstate=$BB_STATE">>/boot/log.txt
  echo "bbjson=$BB_JSON">>/boot/log.txt
else
  echo "/etc/blackbox/blackbox.conf doesnt exist.">>/boot/log.txt
  exit 1
fi

if [ -f "$BB_HASH" ]; then
  BID=$(<$BB_HASH)
fi


# load installlstate in variable
if [ -f "$BB_STATE" ]; then
    INSTALLSTATE=$(<$BB_STATE)
fi

# $(</etc/blackbox/)


if [ "$1" == "check" ]; then

    echo "INSTALLSTATE=$INSTALLSTATE"
    # check installstate, if installstate == 0, copy files.
    if [ "$INSTALLSTATE" == "1" ]; then
        cp -r -v -f /boot/installsrc/usr/share/blackbox /usr/share
        echo "2">$BB_STATE
        INSTALLSTATE=2
    fi

    if [ "$INSTALLSTATE" == "2" ]; then
        cp -r -v -f /boot/installsrc/usr/share/blackbox /usr/share
        includeSources
        echo "3">$BB_STATE
        INSTALLSTATE=3
    fi

    if [ "$INSTALLSTATE" == "3" ]; then

        if ! is_command "git"; then
            /boot/dietpi/dietpi-software install 17 --unattended
        else
            echo "4">$BB_STATE
            INSTALLSTATE=4
        fi
    fi

    if [ "$INSTALLSTATE" == "4" ];then
        if ! is_command "lighttpd"; then
            /boot/dietpi/dietpi-software install 81 --unattended
        else
            echo "5">$BB_STATE
            INSTALLSTATE=5
        fi
    fi

    if [ "$INSTALLSTATE" == "5" ]; then
        apt-get -y install php-common php-sqlite3 php-xml php-intl php-zip php-mbstring php-gd php-apcu php-cgi composer dialog dhcpcd5 dnsutils lsof netcat idn2 dns-root-data composer
        echo "6">$BB_STATE
        INSTALLSTATE=6
    fi


    if [ "$INSTALLSTATE" == "6" ]; then
        mkdir -p /var/www/html/blackbox
        make_repo /var/www/html/blackbox https://github.com/jerryhopper/blackboxweb.git
        echo "7">$BB_STATE
        INSTALLSTATE=7
    fi


    if [ "$INSTALLSTATE" == "7" ]; then
        find_IPv4_information
        piholesetupvarsconf
        piholeftlconf

        #/boot/dietpi/dietpi-software install 81 --unattended
        echo "8">$BB_STATE
        INSTALLSTATE=8
    fi

    if [ "$INSTALLSTATE" == "8" ]; then
            echo "install started : pihole">>/boot/log.txt
            #curl -L https://install.pi-hole.net | bash /dev/stdin --unattended
            curl -L https://raw.githubusercontent.com/jerryhopper/pi-hole/master/automated%20install/basic-install.sh  | bash /dev/stdin --unattended
            #telegram "install finished : pihole"
            echo "install finished : pihole">>/boot/log.txt
        echo "9">$BB_STATE
        INSTALLSTATE=9
    fi

    if [ "$INSTALLSTATE" == "9" ]; then

        usermod -a -G pihole www-data

        # Set repo to V5 beta
        echo "release/v5.0" | sudo tee /etc/pihole/ftlbranch

        #devicelog "[v$VERSION] Checkout release/v5.0 CORE "
        echo "yes"|pihole checkout core release/v5.0

        #devicelog "[v$VERSION] Checkout release/v5.0 WEB "
        echo "yes"|pihole checkout web release/v5.0

        #devicelog "[v$VERSION] Usermod "
        usermod -a -G pihole www-data

        #devicelog "[v$VERSION] edit lighttpd "
        sed -i -e 's/pihole\/index.php/blackbox\/index.php/g' /etc/lighttpd/lighttpd.conf


        echo "10">$BB_STATE
        INSTALLSTATE=10
    fi



fi

if [ "$1" == "install" ]; then
    echo "INSTALLSTATE=$INSTALLSTATE"
fi

if [ "$1" == "configure" ]; then
    echo "INSTALLSTATE=$INSTALLSTATE"
fi

